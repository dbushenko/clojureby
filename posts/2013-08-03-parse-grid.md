#title: Распознавание японского кроссворда. Часть 2: Распознаём сетку.
#tags: clojure_tips news
#date: 2013-08-03
#author: Никита Белоглазов (nikelandjelo@gmail.com)

### Серия

[Часть 1: Знакомим OpenCV с Clojure.](/2013-07-18-opencv-from-clojure.html)

### Введение

В прошлой статье был установлен OpenCV для работы из Clojure. Теперь пришло время непосредственно распознать кроссворд. Распознавание разобъём на 2 части: сначала определим координаты сетки кроссворда, а также координаты клеток с цифрами. Дальше уже распознаем полученные цифры. В этой статье будет описана первая часть: распознавание сетки и определение клеток с цифрами. В статье не будет кода, больше будет описания какие методы были использованы в процессе обработки. Опыта в обработке изображений у меня нет, и способы весьма вероятно не оптимальны, но они работают для моих примеров. Буду очень рад, если кто-нибудь предложит способы улучшения. Я старался работать только со стандартными алгоритмами из OpenCV, не работая с пикселями изображения напрямую. Если реализовывать алгоритмы, взаимодействующие с пикселями, то скорость будет очень невысокой из-за джавы и кложура.

### Этапы

Весь процесс будет состоять из 7 этапов:

1. [Загружаем изображение](#load_image)
2. [Бинаризация](#binarization)
3. [Скелетизация](#skeletonization)
4. [Находим узлы сетки](#knots)
5. [Добавляем потерянные узлы](#lost_knots)
6. [Строим клетки](#cells)
7. [Находим клетки с цифрами](#digit_cells)

На первом этапе у нас есть файл с изображением кроссворда. После последнего этапа мы должно получить мапку, в которой будут содержаться координаты (4 угла) клеток, содержащих цифры.

### <a id="load_image"></a> Загружаем изображение

Для начала прочитаем изображение из файла `nono.jpg` и преобразуем его в чёрно-белое. Для этого воспользуемся методами [Highui.imread](http://docs.opencv.org/java/org/opencv/highgui/Highgui.html#imread%28java.lang.String%2C%20int%29).

Так же уменьшим размеры изображение так, чтобы максимальный размер был 1000 при помощи метода [Imgproc.resize](http://docs.opencv.org/java/org/opencv/imgproc/Imgproc.html#resize%28org.opencv.core.Mat%2C%20org.opencv.core.Mat%2C%20org.opencv.core.Size%2C%20double%2C%20double%2C%20int%29). Это заметно ускорит время обработки изображения.

Результат:

<img src="http://s5.postimg.org/ig6hm7xav/step1.png"/>

### <a id="binarization"></a> Бинаризация (thresholding)

Удобнее обрабатывать бинарное изображение, в котором только 2 цвета: чёрный и белый, вместо 256 оттенков серого. Тем более в нашей задаче оттенки серого и не нужны. Самый простой способ бинаризации - задать порог, например 128 и все значения меньше 128 установить в 0 (чёрный), больше или равно 128 установить в 255 (белый). Но это не очень подходит в случае фотографий, т.к. из-за разной освещённости на разных участках фотографий может получиться так, что одна часть будет почти вся белая (очень хорошее освещение), а другая чёрная (тёмное освещение). Для исправления этого недостатка можно воспользоваться адаптивной бинаризацией (adaptive thresholding). Отличие адаптивной от обычной состоит в том, что в адаптивной для каждого пикселя высчитывается свой порог исходя из анализа его окружения. Например можно взять всех соседей на в диапазоне 5x5, посчитать среднее и взять его как порог. Если текущий пиксель меньше среднего - красим в чёрный, если больше - в белый. Для адаптивной бинаризации OpenCV предоставляет метод [Imgproc.adaptiveThreshold](http://docs.opencv.org/java/org/opencv/imgproc/Imgproc.html#adaptiveThreshold%28org.opencv.core.Mat%2C%20org.opencv.core.Mat%2C%20double%2C%20int%2C%20int%2C%20int%2C%20double%29). Я воспользовался бинаризацией используя среднее по окрестности 21х21.

Результат:

<img src="http://s5.postimg.org/mhnkrvplj/step2.png"/>

### <a id="skeletonization"></a> Скелетизация

Теперь начинается интересное. Для дальнейшей обработки скелетизируем изображение - "утоньшим" все линии так, что они станут шириной в 1 пиксель. Это нам потом позволит удобно находить узлы сетки - пересечения чёрных линий.

Я воспользовался алгоритмом скелетизации при помощи [математической морфологии](http://ru.wikipedia.org/wiki/Математическая_морфология). Для скелетизации использовались 2 морфологочиские операции hit-or-miss и утоньшение (thinning).

* [hit-or-miss](http://homepages.inf.ed.ac.uk/rbf/HIPR2/hitmiss.htm) преобразование позволяет находить точки, удовлетворяющие определённому шаблону. Например можно найти все чёрные точки, у которых все соседи - белые. Или все угловые точки. По ссылке достаточно хорошо описано, что это за операция, а так же даны примеры.
* [утоньшение](http://homepages.inf.ed.ac.uk/rbf/HIPR2/thin.htm) преобразование удаляет (красит в чёрный) из изображения все точки, удовлетворящие шаблону. Т.е. берётся изображение, задаётся шаблон, находятся все подходящие точки при помощи hit-or-miss и закрашиваются в чёрный. Именно утоньшение и использовалось для скелетизации.

В OpenCV не реализованы операции hit-or-miss и утоньшение. hit-or-miss достаточно легко реализуется вручную, используя базовые морфологические операции OpenCV: [пример](http://opencv-code.com/tutorials/hit-or-miss-transform-in-opencv/). Утоньшение реализуется ещё проще, нужно вычислить hit-or-miss и вычесть его из исходного изображения.

Скелетизация производится следующим образом: есть исходное изображение и набор шаблонов. Далее по очереди выполняется операция утоньшение для каждого шаблона. Как только утоньшению нечего удалять, то считается, что скелет построен. В качестве шаблонов использовались 2 шаблона из [статьи](http://homepages.inf.ed.ac.uk/rbf/HIPR2/thin.htm) и их повороты.

Ещё стоит отметить, что для морфологоческих операций цвет фона - цвет 0 (чёрный). В нашем случае как раз наоборот, цвет фона - белый. Поэтому перед морфологическими операциями изображение инвертируется, а также инвертируется результат операции, чтобы обратно получить изображение с белым фоном.

Результат:

<img src="http://s5.postimg.org/swmlojwbb/step3.png"/>

Изображение бледное, т.к. ширина всех линий - 1 пиксель.

### <a id="knots"></a> Находим узлы сетки

Узлы сетки - точки пересечения прямых чёрных линий. Зная их можно восстановить сетку. Узлы я искал при помощи операции hit-or-miss, где использовал такие шаблоны-кресты:

```text
+---+ +---+
|010| |011|
|111| |110|
|010| |010|
+---+ +---+

+----+ +----+
|0010| |0010|
|0011| |1110|
|1100| |0111|
|0100| |0100|
+----+ +----+
```
а также всевозможные повороты на 90° и отображения на 180°. Единицы - чёрные пиксели, нули - белые.

После этого мы получили набор точек. Теперь осталось удалить лишние (которые на самом деле не являются узлами сетки, а попали случайно) и так же хорошо бы для всех узлов найти их соседей: левого, правого, верхнего и нижнего. Объединим эти 2 задачи. Для фильтрации и нахождения соседей я исходил из 2 предположений:

* большинство найденных точек являются узлами сетки
* 4 ближайших точки для каждого узла являются его соседями

Для быстрого поиска ближайших точек узла я воспользовался [K-d деревом](https://ru.wikipedia.org/wiki/K-мерное_дерево) и его реализаций для кложура [clj-kdtree](https://github.com/abscondment/clj-kdtree). Данная структура позволяет быстро находить ближайших соседей для n-мерных точек, в нашем случае они двумерные.

Алгоритм фильтрации и группировки:

1. Построить K-d дерево по набору точек-кандидатов.
2. Определить размер клетки. Размер клетки - расстояние между двумя соседними узлами, т.к. 4 узла являются углами клетки. Я высчитывал размер клетки, как среднее из всех расстояний от каждой точки кандидата до 4 ближайших точек. При этом я отбрасывал 10% наименьших и 10% набольших расстояний, чтобы убрать левые точки. Обозначим размер клетки S.
3. Удалить все точки, у которых меньше 2 соседей на расстоянии S±ε.
4. Перебрать все оставшиеся точки, найти для каждой 4 соседа и по углу между текущей и соседом определить направление. Если оказалось, что есть несколько соседей с одним направлением, например у верхней левой угловой точки только 2 соседа, а мы взяли 4, то берутся ближайшие.

В результате этого этапа мы получаем мапку, в которой ключами являются координаты узлов, а значениями - мапки соседей.

Результат (найденные узлы обведены в кружки):

<img src="http://s5.postimg.org/6v0ws917b/step4.png"/>

### <a id="lost_knots"></a> Добавляем потерянныe узлы

Из результата предыдущего этапа можно заметить, что не все узлы были найдены. Например не был найден узел внизу слева. А также были пропущены все граничные узлы, т.к. они не удовлетворяют шаблонам-крестам. На данном этапе восстанавливаются потерянные узлы.

Сначала восстанавливаются потерянные внутренние узлы. Для каждого узла мы смотрим, каких соседей ему не хватает. Если на какой-то пропавший узел подали заявки 3 или 4 существующих узла, то восстанавливаем этот узел. Координаты вычисляются как среднее из его "волнующихся" соседей. В нашем примере есть много пропавших узлов с 1 соседов (все узлы по границам), 2 узла с 2 соседями (в левом верхнем углу) и 1 узел с 4 соседями (внутри слева внизу). Из всех данных узлов восстанавливаем только последний, т.к. на него подало заявку 4 существующих узла.

Теперь восстановим граничные узлы. Для этого узлы, у которых нет правого соседа, продлим направо и получим правых соседей. Аналогично с левыми, верхними и нижними.

Результат:

<img src="http://s5.postimg.org/9qdzz457b/step5.png"/>

### <a id="cells"></a> Строим клетки

Самое сложное уже позади. Остались достаточно несложные этапы.

Восстановим клетки. Клетка - четырёхугольник, в котором точки идут в следующем порядке: верхняя левая, верхняя правая, нижняя правая, нижняя левая. Восстановление весьма тривиально. Берём каждый узел и идём по соседям направо, вниз, налево. Таким образом мы получили 4 узла, формирующие клетку. Иногда какой-то из соседей может отсутствовать, тогда мы пропускаем такую клетку. В конце концов получим набор клеток. Как и в прошлом этапе, некоторые внутренние клетки могут отсутствовать, их тоже можно восстановить похожим способом.

Результат:

<img src="http://s5.postimg.org/oav2ty05z/step6.png"/>

### <a id="digit_cells"></a> Находим клетки с цифрами

Определение того, есть ли в клетке цифра сделано весьма простым и наивным способом. Но пока что >он работает на моих примерах. Дана клетка (четырёхугольник). Выделим подкартинку, размером в половину клетки, располагающася в центре клетки. Посчитаем число чёрных пикселей. Если их больше 3, то считаем, что это цифра, иначе считаем, что клетка пустая. Этот не будет работать, если у нас есть шумы в клетках или если клетка очень сильно деформирована, тогда подкартинка может зайти на границу клетки.

Результат (клетки с цифрами помечены крестом):
<img src="http://s5.postimg.org/w4vofc7yv/step7.png"/>

### Заключение

Мы научились определять структуру кроссворда: его размер и координаты клеток с цифрами. Осталось научиться превращать клетку с цифрой в настоящую цифру и цель будет достигнута.

Стоит заметить, что данный метод основывается на том, что все цифры тоже располагаются в сетке. К сожалению это не всегда верно. Вот пример кроссворда в котором всё не так красочно:

<img src="http://s5.postimg.org/a9nom4lzr/bad.jpg"/>

Я пока не знаю, как распознавать такой кроссворд. Мой метод может найти центральную сетку и таким образом определить размеры кроссворда и примерные координаты строк и столбцов с числами. А дальше надо как-то выделить уже сами числа. Как это эффективно и быстро сделать я пока не придумал.

Сам проект располагается на [гитхабе](https://github.com/nbeloglazov/nonojure/tree/master/recognition). Он не документирован и там будет мало что понятно. Но можно посмотреть [utils.clj](https://github.com/nbeloglazov/nonojure/blob/master/recognition/src/recognition/utils.clj) и [morphology.clj](https://github.com/nbeloglazov/nonojure/blob/master/recognition/src/recognition/morphology.clj) в которых содержатся утилитные методы, в большинстве своём просто обёртки над OpenCV методами.