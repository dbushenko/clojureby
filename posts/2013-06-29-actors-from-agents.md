#title: Акторы из агентов
#tags: clojure_tips news
#date: 2013-06-29

### Введение
В этом посте я хотел бы рассмотреть, как можно легко превратить кложурных агентов в примитивных акторов. Подробнее про [агентов](http://alexott.net/ru/clojure/clojure-intro/index.html#sec21) и [акторов](http://habrahabr.ru/post/140368/). Меня всегда смущали агенты своей "безмозглостью": они не имеют собственного поведения, они умеют только применять переданную функцию к текущему значению и сохранять полученный результат, как новое значение. Модель акторов является более сложной в реализации и логики, и работы c ними. Рич Хикки частично [объясняет](https://groups.google.com/forum/#!msg/clojure/Kisk_-9dFjE/_2WxSxyd1SoJ), почему он не выбрал модель акторов.

Как-то в скайпе зашёл разговор об акторах и агентах, и Андрей Жлобич подсказал, что если уж так сильно хочется, то в качестве значения в агенте можно хранить функцию обработки сообщений и получить таким образом "мозговитых" агентов - псевдоакторов. Я решил попробовать это реализовать.

Наши доморощенные акторы будут обладать следующими свойствами:

* акторы могут посылать друг другу сообщения;
* акторы не имеют состояния (stateless);
* акторы имеют ссылку на себя и на отправителя текущего сообщения;
* отсутствуют древовидные структуры акторов: кто кого породил, кто отвечает за актор в случае ошибки и т.д.;

По поводу последнего пункта: в агентах есть подобие такой функциональности: можно задать стратегию на случай, если при выполнении функции будет брошено исключение.

### Реализация

Для начала опишем переменные, которые будут содержать ссылку на текущий актор и актор отправитель:

```clojure
(def ^:dynamic *self*)
(def ^:dynamic *sender*)
```

Наши акторы являются в общем-то агентами. В агентах в качестве значения будет храниться функция-обработчик сообщений. Реализуем функцию `process`, которая будет передаваться агентам, данная функция будет применять функцию-обработчик к сообщению. Так же `process` будет биндить переменные `*self*` и `*sender*` в нужные значения:

```clojure
(defn process [f self sender message]
  (binding [*self* self
            *sender* sender]
    (f message) f))
```

Стоит отметить что функция `process` возвращает `f`. Это необходимо для того, чтобы значением агента осталась функция-обработчик.

Теперь реализуем функцию `tell`, которая посылает актору сообщение:

```clojure
(defn tell [actor message]
  (send actor process actor *self* message))
```

В этой функции приходится явно передавать в `process` ссылку на актор-получатель (`actor`) и себя (`*self*`), чтобы принимающий актор мог корректно установить переменные `*self*` и `*sender*`.

Теперь определим макрос, который будет создавать актора. Макрос просто создаёт агента с заданным именем и функцией-обработчиком в качестве значения. Так же я добавил в агент метаданные, содержащие имя актора:

```clojure
(defmacro defactor [name args & body]
  `(def ~name (agent (fn ~args ~@body)
                     :meta {:name '~name})))
```

Собственно всё, акторы готовы к использованию. Но я ещё добавил несколько утилитных функций для удобного логирования из агентов:

```clojure
(defn aname [actor]
  (-> actor meta :name))

(defn log [& args]
  (apply println (aname *self*) "-" args))
```

Теперь приступим к тестированию. Создадим 2 актора: пингер и понгер. Понгер совсем прост. Всё, что он умеет - это принимать сообщения `:ping` и отправлять ответ `:pong` отправителю:

```clojure
(defactor ponger [message]
  (when (= message :ping)
    (log "Got ping from" (aname *sender*))
    (tell *sender* :pong)))
```

Пингер чуточку сложнее. Он уже умеет обрабатывать целых 2 сообщения: `:run` и `:pong`. Сообщение `:run` заставит пингер отправить пинг сообщение понгеру, при сообщении `:pong` оно будет просто залогировано:

```clojure
(defactor pinger [message]
  (case message
    :run (do (log "Send ping message")
             (tell ponger :ping))
    :pong (log "Got pong message")))
```

Теперь запустим:

```clojure
(tell pinger :run)
```

Результат работы:

```
pinger - Send ping message
ponger - Got ping from pinger
pinger - Got pong message
```

[Весь код](https://gist.github.com/nbeloglazov/5891789)

### Заключение

В первую очередь хочется отметить, что это всего лишь эксперимент и ничего серьёзного от него ожидать не стоит. В целом мне понравилось, как с помощью 15 строчек кода можно превратить агентов в почти акторов. Можно ещё делать много мелких улучшений, например добавить в акторы состояние: можно функцию-обработчик хранить в метаданных, а в качестве значения агента хранить состояние актора. Хочется ещё избавиться от глобальных динамических переменных `*self*` и `*sender*`, т.к. они грозят неприятными ошибками, если будут создаваться функции-callback'и внутри актора, но я не придумал, как можно это сделать, кроме явной их передачи в функцию-обработчик.

А вообще если действительно хочется задействовать акторов, то лучше воспользоваться готовыми библиотеками. Для JVM самой стильной, модной, молодёжной библиотекой является скаловская [Akka](http://akka.io/). Существуют обёртки над аккой для кложура: [akka-clojure](https://github.com/jasongustafson/akka-clojure) и [okku](https://github.com/gaverhae/okku), их и стоит посмотреть.







