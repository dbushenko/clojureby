#title: Аутентификация/авторизация в веб-приложении
#tags: clojure_web news
#date: 2013-07-20
#author: Д.Бушенко (d.bushenko@gmail.com)

Я сейчас в отпуске, и есть время для креатива. Так, например, для моего очередного веб-приложения понадобилась система аутентификации и авторизации. В сотый раз писать одно и то же уже не хотелось, поэтому посмотрел в сторону https://github.com/cemerick/friend. Библиотека клёвая, конечно, но больно уже тяжеловесная: много зависимостей, сложно использовать. На моем проекте, где я использовал http-kit и массу других библиотек, произошел конфлит версий с библиотекой friend. Поэтому, волей-неволей, пришлось от неё отказаться.

Тогда я решил написать свою библиотеку аутентификации и авторизации в стиле friend, только максимально простую и предназначенную для одного единственного типа аутентификации -- при помощи форм.

Библиотека находится здесь: https://github.com/dbushenko/noir-auth, пример использования -- здесь: https://github.com/dbushenko/noir-auth-example

Если вкратце, то сердцем библиотеки являются две функции: authenticate и authorized-for.

Функция authenticate принимает на вход имя пользователя, его пароль и список пользователей, для сверки. Этот список должен извлекаться из базы данных, элементы списка должны содержать по меньшей мере три поля:

* :user -- имя пользователя
* :password -- зашифрованный пароль
* :roles -- список ролей пользователя.

Если функция authenticate найдет в списке пользователя, у которого совпадает имя и зашифрованный пароль, то она сохранит этого пользователя в сессии. Соответственно, если пользователь был извлечен из БД, то сохраненный в сессии пользователь будет содержать все извлеченные из БД поля, например, id-шник записи, что может быть очень полезно.

Функция authenticate инкапсулирует знание о том, как зашифрован пароль. Прочтите статью http://adambard.com/blog/3-wrong-ways-to-store-a-password, в ней дано обоснование, почему следует использовать алгоритм шифрования BCrypt. Именно он и используется в функции authenticate. Если при создании пользователя вам нужно зашифровать его пароль, используйте функцию noir-auth.core/generate-password.

Аунтентификация -- это процесс подтверждения, что пользователь -- тот, за кого он себя выдает. Авторизация -- это процесс сопоставления пользователя и его прав на ресурсы. Авторизацию я сделал примерно также, как и Час Эмерик в своей библиотеке Friend. Для задания ролей необходимо использовать иерархии ключевых слов.

Предположим, у нас есть три типа пользователей: пользователь (user), редактор статей (editor), администратор (root). Мы можем создать такую иерархию:

```clojure
(derive ::root ::editor)
(derive ::editor ::user)
```

В этом случае, пользователь с ролью ::root будет иметь все права пользователей, с ролью ::editor, а они, в свою очередь, будут иметь все права роли ::user.

Авторизовать какой-то ресурс для некоторых ролей можно следующим образом:

```clojure
(GET "/user" [] (auth/authorized-for (user-authorized-function)
                                     ::user))

(GET "/root" [] (auth/authorized-for (root-authorized-function)
                                     [::root ::admin]))
```

В макрос authorized-for необходимо передать два параметра: вызов функции и роли, которым эта функция авторизована. Можно задавать как одиночную роль, так и список ролей.

В noir-auth есть еще две важные функции: logout для логаута и current-user, которая вернет сохраненного в сессии пользователя.

Поскольку noir-auth использует сессию, то ваш Ring-хэндлер должен выглядеть таким образом:

```clojure
(ns noir-auth-example.handler
  (:use compojure.core)
    (:require [compojure.handler :as handler]
          [compojure.route :as route]
      [noir.util.middleware :as noir]
      [noir-auth.core :as auth]))
. . .
(def app
  (->
     [(handler/site app-routes)]
     noir/app-handler))
```

Я уже использую noir-auth в своих хобби-проектах и одном коммерческом. Надеюсь, она пригодится и вам.