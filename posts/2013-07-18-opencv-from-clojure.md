#title: Распознавание японского кроссворда. Часть 1: Знакомим OpenCV с Clojure.
#tags: clojure_tips news
#date: 2013-07-18 18:00
#author: Никита Белоглазов (nikelandjelo@gmail.com)

### Введение

В качестве хобби-проекта я решил попробовать реализовать распознователь [японских кроссвордов](http://ru.wikipedia.org/wiki/Японский_кроссворд) на Clojure. На вход программе подаётся фотография кроссворда. На выходе должны получить оцифрованную версию в каком-либо виде (JSON, edn). Опыта в обработке изображений у меня нет никакого (кроме курса в универе, который благополучно забылся). Я решил оформить разработку распознавателя в виде серии статей. Надеюсь, что серия завершится и я реализую его.

Первый вопрос, который у меня возник во время разработки - какую библиотеки для обработки изображений использовать, потому что писать свою и реализовывать стандартные алгоритмы - это отдельная сложная задача. Я попробовал [ImageJ](http://rsbweb.nih.gov/ij/). Плюсы: наиболее мощная библиотека для обработки изображений на Java, много плагинов реализующих различные алгоритмы, легко подключается в `project.clj`. Минусы: ориентированность на GUI, вследствии чего многие плагины и функции невозможно нормально использовать из кода, не очень высокая скорость работы на больших изображениях.

Альтернатива - использовать [OpenCV](http://opencv.org/), одну из самых популярных подобных библиотек в мире. Она написана на С++. Есть джавовская обёртка над OpenCV - [JavaCV](http://code.google.com/p/javacv/). Но не так давно парни из OpenCV сделали [поддержку декстопной джавы](http://opencv.org/opencv-java-api.html) прямо в OpenCV. Плюсы OpenCV: скорость, развитость. Минусы: реализована на С++, из-за этого сложная сборка и настройка проекта. Я остановился на последнем варианте. Далее я опишу процесс установки OpenCV и его знакомства с Clojure.

### Установка OpenCV

На данный момент версия OpenCV для java не добавлена ни в один мавен репозиторий, поэтому одной строчкой в `project.clj` подключить его не получится. Надо ручками скачать исходники OpenCV и собрать. Стоит сказать, что есть [задача](http://code.opencv.org/issues/3097) на добавления библиотеки в мавен, так что в светлом будущем всё будет легко и просто.

Для сборки OpenCV для java лучшего всего следовать их [официальному руководству](http://docs.opencv.org/2.4.4-beta/doc/tutorials/introduction/desktop_java/java_dev_intro.html). Нас интересует только первый шаг: Build OpenCV. Если кратко, то надо сделать 3 шага (для *nix):

1. Скачать исходники OpenCV. Например [отсюда](http://sourceforge.net/projects/opencvlibrary/files/).
2. Создать папку `build` в корне OpenCV и перейти в неё.
2. Сгенерировать make файлы при помощи cmake:
```shell
cmake -DBUILD_SHARED_LIBS=OFF ..
```
3. Собственно собрать проект:
```shell
make -j8
```

Тут надо внимательным к тому, чтобы вывод cmake'а включал java модуль в список To be built. При первой сборке у меня java модуль не собрался. После изучения выяснилось, что у меня старая версия cmake, в которой не ставился флаг `JNI_FOUND`, вследствии чего OpenCV думал, будто у меня не стоит java. Более подробно про эту проблему можно прочитать [здесь](http://code.opencv.org/issues/2931).

После сборки нас интересует 2 файла:

* `lib/libopencv_java246.so` - скомпилированная нативная (С++) часть.
* `bin/opencv-246.jar` - java обёртка, использующая C++ либу и предоставляющее java API для работы с OpenCV.

246 в названиях означает, что я использовал OpenCV 2.4.6. При сборке на windows должна получиться *.dll библиотека. Но я не пробовал, так что не знаю, есть ли там какие-нибудь грабли.

### Создание leiningen проекта

Создадим пустой lein проект:

```shell
lein new opencv
```

Если бы мы работали с обычной java/clojure библиотекой - было бы достаточно прописать зависимость в `project.clj` и всё. Но тут придётся всё делать искусственно. Подключение состоит из нескольких шагов.

#### Подключить `opencv-246.jar`
Добавим либу `opencv-246.jar` в локальный maven репозиторий. Таким образом можно будет прописать её как зависимость в `project.clj` и lein подтянет её из локального репозитория. Для этого воспользуемся плагином [lein-localrepo](https://github.com/kumarshantanu/lein-localrepo), который как раз это и умеет делать.

добавим плагин в `project.clj`:

```clojure
:plugins [[lein-localrepo "0.5.2"]]
```

добавим либу в локальный репозиторий:

```shell
lein localrepo install opencv-246.jar org.opencv/opencv 2.4.6
```

наконец подключим её как зависимость:

```clojure
:dependencies [[org.clojure/clojure "1.5.1"]
               [org.opencv/opencv "2.4.6"]]
```

#### Подключить `libopencv_java246.so`
Нативные библиотеки подключаются в джаве следующим образом: библиотека должна быть в пути, заданному в свойстве `java.library.path`, далее библиотека подключается вызовом [System.loadLibrary](http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#loadLibrary%28java.lang.String%29).

создадим в проекте папку `native`, в которую поместим `libopencv_java246.so`
```shell
mkdir native
mv libopencv_java246.so native
```

зададим свойство `java.library.path` как параметр JVM в `project.clj`:
```clojure
:jvm-opts ["-Djava.library.path=native/"]
```

перед началом работы в REPL'е или clj файле надо подключить `libopencv_java246.so`
```clojure
(clojure.lang.RT/loadLibrary "opencv_java246")
```
тут используется класс `clojure.lang.RT` вместо `System` из-за того, что clojure использует свои собственные загрузчики классов и использование `System.loadLibrary` не даст нужного результата. Ещё стоит отметить, что название библиотеки пишется без префикса `lib` и расширения `.so`.

В конце `project.clj` выглядит следующим образом:
```clojure
(defproject opencv "0.1.0-SNAPSHOT"
  :dependencies [[org.clojure/clojure "1.5.1"]
                 [org.opencv/opencv "2.4.6"]]
  :plugins [[lein-localrepo "0.5.2"]]
  :jvm-opts ["-Djava.library.path=native/"])
```

### Оно работает!

Настало время завести нашу шайтан-машину и проверить на работоспособность. Реализуем пример из OpenCV руководства, в котором создаётся нулевая матрица 5x10, вторая строчка заполняется единицами, пятый столбец заполняется пятёрками и выводится.

```clojure
(clojure.lang.RT/loadLibrary "opencv_java246")

(import [org.opencv.core Mat CvType Scalar])

(defn run []
  (let [m (Mat. 5 10 CvType/CV_8UC1 (Scalar. 0.0))]
    (println "OpenCV Mat:" m)
    (.. m (row 1) (setTo (Scalar. 1.0)))
    (.. m (col 5) (setTo (Scalar. 5.0)))
    (println "OpenCV Mat data:")
    (println (.dump m))))

(run)
```
Получаем вывод:
```
OpenCV Mat: #<Mat Mat [ 5*10*CV_8UC1, isCont=true, isSubmat=false, nativeObj=0x7ff6f4001230, dataAddr=0x7ff6f4002be0 ]>
OpenCV Mat data:
[0, 0, 0, 0, 0, 5, 0, 0, 0, 0;
 1, 1, 1, 1, 1, 5, 1, 1, 1, 1;
 0, 0, 0, 0, 0, 5, 0, 0, 0, 0;
 0, 0, 0, 0, 0, 5, 0, 0, 0, 0;
 0, 0, 0, 0, 0, 5, 0, 0, 0, 0]
```

В процессе работы с изображением очень часто необходимо увидеть его глазами, а не через холодные числа матриц. Для этого в нативном OpenCV есть функция `imshow`, но к сожалению в java она недоступна. Поэтому я реализовал свою версию `imshow`. Суть проста: преобразовать OpenCV'шную матрицу в джавовский `BufferedImage` и показать используя swing. Пример метода преобразующего `org.opencv.core.Mat` в `java.awt.BufferedImage`:
```clojure
(defn to-image [mat]
  (let [bytes (org.opencv.core.MatOfByte.)]
    (org.opencv.highgui.Highgui/imencode ".png" mat bytes)
    (-> (.toArray bytes)
        (java.io.ByteArrayInputStream.)
        (javax.imageio.ImageIO/read))))
```

Для показа изображений я использую [ImageViewer](https://github.com/kazocsaba/imageviewer) от kazoscaba - свинговый компонент для отображения изображений. Полный код функции `show` можно найти в [моём репозитории](https://github.com/nbeloglazov/nonojure/blob/master/recognition/src/recognition/utils.clj#L11).

### Заключение

Теперь у нас есть мощный инструмент для обработки изображений. Конечно его установка весьма длительна и не очень удобна, к тому же на каждом компьютере придётся проделывать эти шаги заново. По крайней мере если на них разная разрядность. Но я пишу распознаватель на 1-2 компьютерах и это не проблема. В следующих частях я буду рассказывать уже непосредственно о процессе распознавания изображений.

